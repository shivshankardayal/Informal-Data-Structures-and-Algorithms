<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
           xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
           xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
  <?dbhtml filename="introduction/index.html" ?>
  <d:title>Introduction</d:title>
  <d:para> 
    First thing first. Definitely this is not the only book on data structures
    and algorithms. There are many great books on the subject. I will mention
    few of those. No links to any online shop will be given as it will show my
    bias towards that store. The first book is the most authoritative book on
    the subject 
    which treats topics in great depth. It is the <d:quote>The Art of Computer
    Programming</d:quote> by Donald E. Knuth. The book is available in several
    volumes. Volume 1 describes Fundamental Algorithms, 2 describes numerical
    algorithms, 3 details sorting and searching and 4A deals with
    combinatorial algorithms. As of now only these volumes have been
    published. But these books are not for weak hearted people and I really
    mean that. This series is very heavy on mathematics and implementation is
    done using a computer designed by Knuth MMIX. However, it is a must read
    for advanced readers. The second book is also a classic. It is
    <d:quote>Introduction to Algorithms</d:quote> written by Thomas H. Cormen,
    Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. This book is
    also known as <d:quote>CLRS</d:quote>. While Knuth is very deep, this book
    covers topics in breadth. Once again an excellent book but examples are
    given in pseudo programming language. There are many other introductory
    books on this subject with little difference in quality and almost all of
    them are a good read.
  </d:para>
  <d:para>
    The subject of this book is data structure and algorithms. That involves
    three words. Data, structure and algorithms. A computer stores and
    manipulates data i.e. information. We use computer to store, manipulate and
    use data. We present same information in many ways which is about
    structure. The data and structure determines that what kind of operations
    i.e. algorithms can be performed over them. For example, we cannot perform
    addition on two character strings but then we can concatenate them using +
    operator in an object-oriented language which support operator
    overloading. Thus, these words summarize the soul of computer programming
    and software. All programs which we use and all operations we do involve
    these three basic elements.
  </d:para>
  <d:para>
    Oh you would say that I missed the word mathematics. Well, then you have
    been observant! That was deliberate. :) Mathematics which will be treated
    in this book is although separate from the main subject but certain
    portions of the book like computer graphics and computational geometry will
    require a great deal of mathematics. Certainly the mathematics part can form
    a new book and can be read as such in isolation but I am a fan of thicker
    books so I intend to make it thick. Since I have no intention of getting it
    printed that, is all good. Such is miracle of digital technology.
  </d:para>
  <d:para>
    There are specific structures which facilitate specific operations. For
    example, a stack allows access of data only 
    from top. A queue is helpful to realize a life-like queue. A linked list
    allows traversal in forward or backward or both directions but not
    random. Binary trees are helpful for faster searches. Graphs can be used
    for path-finding and to solve network problems. Hash maps are very good
    for finding information quickly. These are just few cases which I have
    cited. The area of data structures and algorithms is immense and ever
    expanding.
  </d:para>
  <d:sect1>
    <d:title>Problem to Solution</d:title>
    <d:para>
      Usually while programming you will face the situation when you have to
      write a program to solve a problem. You will end up using few data
      structures and a few algorithms to solve that program. This book
      describes the most common data structures and algorithms which have
      evolved over several centuries of mathematical work by
      mathematicians. Given a problem we build a model of solution (read
      program) in our mind. The details of that mental model varies from
      individual to individual. Once that mental model is built, our brains
      orientation is fixed to a certain way of thinking. Now because of this we
      choose certain data structures and algorithms and try to find out
      solution using data structure and algorithms chosen. Sometimes we are
      successful other times we fail may be partially maybe fully. Now the most
      important thing when we fail is to think over the problem again and get a
      fresh thinking. So better take a break. This is most serious advice I can
      give. Whenever you have difficulty solving a problem for more than 30
      minutes take a break. This will reset your thinking and allow you to
      think in new way and you can try to find the solution afresh.
    </d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Abstract Data Types</d:title>
    <d:para>
      While code is definitely the final goal, to reach there we make models in
      our mind. For example, when we think of numbers as humans we can think of
      numbers without the restriction of range but in case of computers we are
      constrained by the amount of memory available. However, that does not
      stop us from making abstract models because typically computers have
      enough memory available for storing large enough numbers available for
      all practical purposes. An <d:emphasis role="italic"><d:emphasis
      role="bold">abstract data type</d:emphasis></d:emphasis> specifies the
      logical properties of a data type. As you know a data type like
      <d:code>int, char</d:code> and <d:code>float</d:code> represent
      collection of values and these types determine what operations can be
      performed on those types. For example, you should not perform
      multiplication on characters although programmatically it is possible, it
      just does not make sense. Although, other meanings are possible to
      multiplication to a character or string i.e. repetition but certainly not
      multiplication. Thus, the collection of values and operations form an
      abstract mathematical entity that can be implemented using hardware and
      software. This is what is known as <d:quote>abstract data
      type</d:quote>. A formal way to put what an ADT is <d:quote>class of
      objects whose logical behavior is defined by a set of values and a set of
      operations</d:quote>. From experience I know that beginners do not really care
      for ADTs and they simply skip to the implementation part which is not
      good. Unless you understand the concept at an abstract level you will not
      be able to appreciate the semantics of the ADT and as a result your
      implementation may suffer.
    </d:para>
    <d:para>
      When we define an abstract data type we do not worry about efficiency
      whether time or space. Since it is abstract therefore those worries come when we
      implement that. While defining an ADT, we are not worried about
      implementation details. Certain times it may be possible to implement our
      ADT on a piece of hardware or software system. For example, infinitely
      big numbers or strings cannot be implemented in hardware or software
      as said earlier because of memory limitations. But then again for all
      practical purposes an ADT will be useful as help while implementing our
      problem provided you are willing to maintain the semantics.
    </d:para>
    <d:para>
      There are two main ways of defining an ADT, <d:emphasis
      role="italic">imperative</d:emphasis> and <d:emphasis
      role="italic">functional</d:emphasis>. Imperative way of defining an ADT
      is closer to programming languages like C, C++ etc which allow imperative
      programming techniques while functional style is better suited for
      functional languages like Erlang, Haskell, OCaml etc. However, I will
      deviate from the formal style a bit to make it easy for you to understand
      ADTs without knowledge of a programming language so that you can evaluate
      it as a mathematical model.
    </d:para>
    <d:para>
      Let us consider an example ADT then we will dissect that after:
    </d:para>
    <d:screen><![CDATA[ADT UnsignedInteger
Object: An ordered subrange of integers starting at zero and ending at a
maximum value of UINT_MAX on the computer.

/* operations */

for all x, y in N(set of natural numbers) and true, false in booleans

true  ::== 1 (UnsignedInteger)
false ::== 0 (UnsignedInteger)

Zero(): UnsignedInteger          => 0
IsZero(x): Boolean               => if(x == 0) IsZero = true else false
Add(x, y): UnsignedInteger       => if(x + y < UINT_MAX) Add = x + y
                                    else Add = (x + y)%(UINT_MAX + 1)
Equal(x, y): Boolean             => if (x == y) Equal = true else false
Sub(x, y): UnsignedInteger       => if(x > y) Sub = x - y
                                    else Sub = positive of 2's complement
                                    with MSB is not sign bit
Mul(x, y): UnsignedInteger       => if((x * y) < UINT_MAX) Mul = x * y
                                    else Mul = (x * y)%(UINT_MAX + 1)
Div(x, y): UnsignedInteger       => Div = Quotient of x/y
Mod(x, y): UnsignedInteger       => Mod = Remainder of x/y]]></d:screen>
    <d:para>
      You, my observant reader, would have noticed that this is not an ADT in
      its purest
      sense because we have cared about hardware i.e. assumed that it
      implements 2's complement. Your observation is correct. It is not an ADT
      but I have tried to make sure that this ADT works on modern computers
      which work on 2's complement. Certainly this will not work on systems
      like UNIVAC which implement 1's complement in hardware.
    </d:para>
    <d:para>
      However, that is not important part. The important part is to learn as
      how you specify an ADT so that it works. Let us try to learn what has
      been described in ADT. This ADT describes unsigned integers much like
      that found in a statically typed language like C or C++. This ADT starts
      at 0 and ends at a specific value specified by
      <d:code>UINT_MAX</d:code>. What would be <d:code>UINT_MAX</d:code> is not
      specified as an optimum value of that depends in internal details of
      hardware. <d:code>Zero()</d:code> is an operation which always returns
      zero. <d:code>IsZero()</d:code> is an operation which returns
      <d:code>true</d:code> if argument is zero else
      <d:code>false</d:code>. <d:code>true</d:code> and <d:code>false</d:code>
      have been specified as their typical Boolean notations of 1 and 0
      respectively. <d:code>Add()</d:code> adds two unsigned integers if their
      sum is less than <d:code>UINT_MAX</d:code>, if it is more than that then
      it is rotated which is based on the behavior of hardware again. Now I
      leave it up to you to figure rest of ADT.
    </d:para>
    <d:sect2>
      <d:title>An ADT for rational numbers</d:title>
      <d:para>
        To foster the ideas as how to represent an ADT let us consider another
        example of rational numbers. A rational number is a fraction which
        either terminates or repeats upon division for example, <math
        xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mfrac
        bevelled="true"><mn>1</mn><mn>2</mn></mfrac><mo>,</mo><mfrac
        bevelled="true"><mrow><mo>&#160;</mo><mn>2</mn></mrow><mn>3</mn></mfrac><mo>,</mo><mfrac
        bevelled="true"><mn>7</mn><mn>9</mn></mfrac></math>. Thus, we see that
        denominators and numerators are integers. We also have to consider the
        sign of these rational numbers, which, may be positive or negative
        which we will represent using character data type for example. For
        completeness let us define a minimalistic character abstract data type
        as well. 
      </d:para>
      <d:screen><![CDATA[ADT Character
Object: A character on English PC-104 keyboard which can fit in 8 bits

character ::== a-z,A-Z,0-9,`~!@#$%^&*()-_=+[{]}\|;:'",<.>/?(space)]]>
c is one of the characters being one of the above.

value(c): UnsignedInteger                  => if(c == a-z)
                                                return 0-25
                                              else if(c == A-Z)
                                                return 26-51
                                              else if(c == 0-9)
                                                return 52-61
                                              else
                                                sequential value in above list
                                                from remaining characters
      </d:screen>
      <d:para>
        I have kept the ADT character minimalistic to be enough to serve
        our typical usage. <d:code>(space)</d:code> specifies the space bar
        on your keyboard. We have defined characters in terms of integral value
        so that we can store it in memory because memory can contain only
        sequence of bits. Characters really cannot be stored in memory as it
        is. This will allow us to apply equality for two characters as well as
        other operations which can be applied to integers though I have left
        them for you as an exercise. First three commas are just field
        separators.
      </d:para>
      <d:para>
        Let us define our rational number ADT now.
      </d:para>
      <d:screen><![CDATA[ADT Rational
Object: A rational number which has a finite denominator and numerator.

/* Operations */
for all n1, n2, d1 and d2 as UnsignedInteger with d1 != 0 and d2 != 0
and true and false are our usual Booleans.
s1 and s2 are signs represented as Character - and +.

rational ::== <numerator, denominator, sign> where numerator and denominator
are UnsignedInteger, denominator != 0 and sign is a character '+' or '-'

MakeRational(n, d, s): Rational             => return <n, d, s>
IsEqual(n1, d1, s1, n2, d2, s2): Boolean    => if((n1*d2 == n2*d1) &&
                                               ((s1 == s2 == '+')||(s1 == s2 == '-')))
                                               return true
                                               else return false
Greater(n1, d1, s1, n2, d2, s2): Rational   => if( s1 == s2)
                                                 if((n1*d2) >(n2*d1))
                                                 return <n1, d1, s1>
                                               else if(s1 == '+')
                                                 return <n1, d1, s1>
                                               return <n2, d2, s2>
Add(n1, d1, s1, n2, d2, s2): Rational       => if(s1 == s2)
                                                 return <(n1*d2 + n2*d1),
                                                 d1*d2, s1>
                                               else if(Greater(n1, d1, s1, n2,
                                                 d2, s2) == <n1, d1, s1>)
                                                 return <(n1*d2 - n2*d1),
                                                 d1*d2, s1>
                                               else
                                                 return <(n2*d1 - n1*d2),
                                                 d1*d2, s2>
Sub(n1, d1, s1, n2, d2, s2): Rational       => if(s1 == s2)
                                                 return <(n1*d2 - n2*d1),
                                                 d1*d2, s1>
                                               else if(Greater(n1, d1, s1, n2,
                                                 d2, s2) == <n1, d1, s1>)
                                                 return <(n1*d2 + n2*d1),
                                                 d1*d2, s1>
                                               else
                                                 return <(n2*d1 + n1*d2),
                                                 d1*d2, s2>
Mul(n1, d1, s1, n2, d2, s2): Rational       => if(s1 == s2)
                                                 return <n1*n2,
                                                 d1*d2, '+'>
                                               else 
                                                 return <n1*n2,
                                                 d1*d2, '-'>
Div(n1, d1, s1, n2, d2, s2): Rational       => if(s1 == s2)
                                                 return <n1*d2,
                                                 d1*n2, '+'>
                                               else 
                                                 return <n1*d2,
                                                 d1*n2, '-'>]]>
      </d:screen>
      <d:para>
        It is not at all hard to understand the rational number ADT and I think
        that it is self-explanatory. I have used this informal style of ADT
        description for now but when I will be describing data structures I
        will stick to a more formal style.
      </d:para>
      <d:para>
        One particular operation I would like to point out is
        <d:code>IsEqual</d:code> operation. Usually ADTs are equal when they
        have equal value but in case of rational numbers they can be equal even
        if absolute fractions are not equal. Rather, the different fractions
        will have equal value in their reduced form, for example, <math
        xmlns="http://www.w3.org/1998/Math/MathML"
        display="inline"><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>,</mo><mfrac><mn>2</mn><mn>4</mn></mfrac><mo>,</mo><mfrac><mn>3</mn><mn>6</mn></mfrac></math>.
      </d:para>
      <d:para>
        Now that we have learned small bits of how to define an ADT let us turn
        our attention to more important philosophical questions.
      </d:para>
    </d:sect2>
    <d:sect2>
      <d:title>Advantages of ADTs</d:title>
      <d:sect3>
        <d:title>Encapsulation</d:title>
        <d:para>
          An ADT guarantees the properties and operations about itself. This
          allows programmer of ADT that only so much is needed to satisfy the
          requirements posed by ADT. The implementation may be complex but that
          is abstracted by a very simple interface definition. Thus, a great
          deal of abstraction is achieved by specifying the ADT for the user of
          ADT. As a programmer of ADT we are worried only about satisfying
          the interface and properties requirements of ADT and nothing more.
        </d:para>
      </d:sect3>
      <d:sect3>
        <d:title>Localization of Change and Isolation from Implementation</d:title>
        <d:para>
          As a user of ADT we are not worried if the implementation changes
          internally as long as ADTs' interface does not change. Since the
          implementation must adhere to interfaces defined by the ADT in
          question we as user of ADT get a guarantee that we are isolated from
          the implementation. Thus, a change in implementation of ADT does not
          warrant a change in our code as ADT user. For example, a car's
          accelerator, break and clutch are always in the same positional order
          irrespective of change of mechanics inside. As you can see that
          changes in implementation are localized to the implementation details
          and users of the ADT are not effected which allows decoupling of ADT
          implementation and its usage which results in parallel work on both
          sides. 
        </d:para>
      </d:sect3>
      <d:sect3>
        <d:title>Flexibility</d:title>
        <d:para>
          An ADT can be implemented in different ways as you will see soon when
          I will present implementation of queues and stacks both using an
          array and a linked list. However, the users of those queues and
          stacks are free to switch between the two implementations as they see
          fit because the interfaces of ADTs remain same. This allows us to use
          different implementations as per requirement of our problem giving us
          flexibility and efficiency.
        </d:para>
      </d:sect3>
    </d:sect2>
    <d:sect2>
      <d:title>Complexity Considerations for an ADT</d:title>
      <d:para>
        As I have said that while defining an ADT, we are not worried about
        performance criterion of implementation. However, there are two schools
        of thoughts. One faction thinks that these should not be part of ADT
        while the other thinks that ADT should guarantee a minimum on
        performance criterion in terms of memory and time. For example, I will
        quote the author of STL, Alexander Stepanov who puts forth his argument
        as: <d:blockquote><d:attribution>Alexander
        Stepanov</d:attribution><d:para>The 
        reason for introducing the notion of abstract 
        data types was to allow interchangeable software modules. You cannot
        have interchangeable modules unless these modules share similar
        complexity behavior. If I replace one module with another module with
        the same functional behavior but with different complexity tradeoffs,
        the user of this code will be unpleasantly surprised. I could tell him
        anything I like about data abstraction, and he still would not want to
        use the code. Complexity assertions have to be part of the
        interface.</d:para></d:blockquote>
        As far as I think complexity considerations should be part of ADTs
        because based on these guarantees we can choose what we will use and
        what we will not. In that sense, you can say that I agree with the
        opinion of Stepanov. In our trivial ADTs which we have seen I have
        omitted the complexity considerations but before we can include
        complexity considerations we have to include those in our
        analysis. However, before we can really introduce complexity
        considerations in our ADTs we have to learn what is complexity and how
        do we evaluate that. But before we can learn how to compute complexity
        of an algorithm let us have a concrete definition for it.
      </d:para>
    </d:sect2>
  </d:sect1>
  <d:sect1>
    <d:title>What is an Algorithm?</d:title>
    <d:para>
      The word algorithm comes from the name of the 9th century Persian Muslim
      mathematician Muḥammad ibn Mūsā al-Khwārizmī. Algorism
      originally referred only to the rules of performing arithmetic using
      Hindu-Arabic numerals but evolved via European Latin translation of
      al-Khwārizmī's name into algorithm by the 18th century. al-Khwārizmī
      wrote a book titled <d:quote>On the Calculation with Hindu
      Numerals</d:quote> in about 825 AD, and was principally responsible for
      spreading the Indian system of numeration throughout the Middle East and
      Europe. It was translated into Latin as <d:quote>Algoritmi de numero
      Indorum</d:quote> (in English, <d:quote>Al-Khwarizmi on the Hindu Art of
      Reckoning</d:quote>). The term <d:quote>Algoritmi</d:quote> in the title
      of the book led to the term <d:quote>algorithm</d:quote>. Usage of the 
      word evolved to include all definite procedures for solving problems or
      performing tasks. The question is a what is an algorithm. An algorithm is
      a finite sequence of well-defined operations on some input data which
      produces an output in finite amount of time and requires finite amount of
      space to hold its data which can be presented in a well-defined
      formal language for evaluation of a function.
    </d:para>
    <d:para>
      The concept of algorithm has existed for millennia, however a partial
      formalization of what would become the modern algorithm began with
      attempts to solve the Entscheidungsproblem (the <d:quote>decision
      problem</d:quote>) posed by David Hilbert in 1928, who was a great
      mathematician born in Prussia(modern Russia). Coincidently, John Von
      Neumann(father of modern computer architecture and inventor of merge
      sort) was his assistant for some time. The geniuses of Hilbert and
      Neumann is well 
      known. Hilbert's problems which is a list of 23 problems have fueled much
      of mathematical research of 20th century while Neumann contributed to
      development of computers, nuclear bombs both Uranium and Hydrogen bombs
      as well as towards development of ICBMs. Subsequent formalizations were
      framed as attempts to define <d:quote>Effective calculability</d:quote>,
      those formalizations included the Gödel–Herbrand–Kleene recursive
      functions, Alonzo Church's lambda calculus, Emil Post's
      <d:quote>Formulation 1</d:quote>, and Alan Turing's Turing
      machines. We will study  Lambda Calculus and Turing Machines
      later in this book.
    </d:para>
    <d:para>
      Let us consider the classic Euclid's algorthim for finding greatest
      common divisor for two numbers. This algorthm has been described by
      Euclid in his book Elements (book vii, propositions i and ii). Given two
      numbers say a and b following steps need to be executed for finding
      remainder.
    </d:para>
    <d:para>
      <d:emphasis role="bold">Algorithm A</d:emphasis>
      (<d:emphasis role="italic">Euclid's algorithm</d:emphasis>) Given two
      positive integers <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math> and <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi></math> find the
      greatest common divisor, i.e. the 
      largest positive integer which evenly divides (remainder after division
      is 0) both <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math> and <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi></math>.
    </d:para>
    <d:para>
      <d:emphasis role="bold">A1.</d:emphasis> [Find remainder.] Divide <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math> 
      by <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi></math>. Say <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math> is remainder
      (<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math> will
      certainly be <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn><mo>&#8804;</mo><mi>r</mi><mo>&lt;</mo><mi>b</mi></math>). 
    </d:para>
    <d:para>
      <d:emphasis role="bold">A2.</d:emphasis> [Is it zero?] If <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi><mo>=</mo><mn>0</mn></math>
      terminate execution b is the GCD.
    </d:para>
    <d:para>
      <d:emphasis role="bold">A3.</d:emphasis> [Exchange values.] Set <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>=</mo><mi>b</mi></math> 
      and <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi><mo>=</mo><mi>r</mi></math>. Goto
      step A1. 
    </d:para>
    <d:para>
      I will use the word A for alorithm. This algorithm will have a
      monotonically increasing suffix which will be a positive integer. When
      these algorithms are later referenced a hyperlink will be made to
      refernce back to the algorithm.
    </d:para>
    <d:para>
      Some algorithms will have flowcharts given for them. For example, given
      below is the flowchart for Euclid's algorithm.
    </d:para>
    <d:figure>
      <d:title>Flowchart for Euclid's GCD Algorithm</d:title>
      <d:mediaobject>
        <d:imageobject>
          <d:imagedata fileref="../images/euclid_fc.png" align="center" />
        </d:imageobject>
      </d:mediaobject>
    </d:figure>
    <d:para>
      Given below is a sample C program which implements this algorithm:
    </d:para>
    <d:programlisting role="CLexer"><![CDATA[#include <stdio.h>

int main()
{
  int a=0, b=0, r=1;

  printf("Enter two positive integers separated by space:\n");
  scanf("%d %d", &a, &b);

  while(r != 0) {
    r = a % b;
    if(r == 0)
      break;
    else {
      a = b;
      b = r;
    }
  }

  printf("GCD is %d\n", b);

  return 0;
}]]></d:programlisting>
    <d:para>
      Note that terminating condition for our program is that remainder becomes
      zero. Typically we initialize variables with value 0 in C but in this
      case it must be non-zero.
    </d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Complexity of an Algorithm</d:title>
    <d:para>
      There can be several algorithms to achieve the same effect on a
      particular set of data. However, any two methods may have different
      requirements on time constraint. One may take more or less or equal time
      than the second one. We definitely always want an algorithm which
      consumes less time. Time may not be only contraint all the
      time. Sometimes we may be bound by amount of memory available to
      use. This may forbade us from using those algorithms which consume more
      memory even though they run faster.
    </d:para>
    <d:sect2>
      <d:title>Big O Notation</d:title>
      <d:para>
        There are two ways by which you can categorize complexity. The
        first categorization is by resource consumption. We measure these using
        consumption of memory and CPU. Memory consumption is known as space
        complexity and CPU consumption is known as time complexity. The second
        categorization is by the methods by which we measure complexity of an
        algorithm. One of the popular methods is Big-O notation denoted by <math
        xmlns="http://www.w3.org/1998/Math/MathML"
        display="inline"><mi>O</mi></math>. Big-O notation focuses on upper bound
        of algorithms for huge sets of data(tending to be infinity) and thus is
        known as asymptotic 
        complexity. Another method which is less popular is amortized
        complexity. Amortized complexity is not concerned about worst-case
        performance but rather average run time for all cases.  In an algorithm
        an operation may be costly but then its frequency may be less. Amortized
        complexity takes care of this fact and tries to balance the complexity
        value. Thus, we can
        safely say that Big-O notation is a guarantee but amortized notation is a
        probabilistic way of deducing run-time or rather more practical
        notion. Since it is much easier to computer Big-O complexity we will
        focus on it but from time to time I will also introduce amortized
        complexity for analysis of algorithms where suitable.
      </d:para>
      <d:para>
        Big-O is a member of a larger family of notations that is called Landau
        notation, Bachmann–Landau notation (after Edmund Landau and Paul
        Bachmann). Mathematically it tells us that how closely a finite series
        approximates a given function, especially for a truncated Taylor series
        or asymptotic expansion.
      </d:para>
      <d:para>
        One more concept is there for classification of algorithms. This
        classification is based on the fact whether data is available in its
        entirety to the algorithm or not. If the algorithm requires that data
        must be available for algorithm to work then it is known as <d:emphasis
        role="italic">offline</d:emphasis> algorithm. Algorithms which do not
        require entire data to be available on work on part of data at a point of
        time are known as <d:emphasis role="italic">online</d:emphasis>
        algorithms. Clearly as you can fathom, online algorithms will have better
        performance that offline algorithms. If ratio of performance of an online
        algorithm and its counterpart offline algorithm is bounded, the
        online algorithm is called <d:emphasis
        role="italic">competitive</d:emphasis>. Also, a point worth noticing is
        that all online algorithms do not have an offline counterpart.
      </d:para>
      <d:para>
        Now let us try to understand what is big-O notation and how to compute
        it. Consider two functions <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>. Let
        us assume that these functions operate on a subset of real numbers. Then
        in big-O notation <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        is written in terms of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        as follows:
      </d:para>
      <d:informalequation>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>&#160;</mo><mi>a</mi><mi>s</mi><mo>&#160;</mo><mi>x</mi><mo>&#8594;</mo><mo>&#8734;</mo></math>
      </d:informalequation>
      <d:para>
        if and only if there is a positive constant <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> such that
        for all sufficiently large values of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math>, <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>~</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math> is at most <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> multiplied
        by <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mo>~</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        in absolute value. That is, <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>~=</mo><mo>~</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        if and only if there exists a positive real number <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> and a real
        number <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>0</mn></msub></math>
        such that
      </d:para>
      <d:informalequation>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>|</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>|</mo><mo>&#8804;</mo><mi>K</mi><mo>|</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>|</mo><mo>&#160;</mo><mo>&#160;</mo><mo>&#8704;</mo><mo>&#160;</mo><mi>x</mi><mo>&gt;</mo><msub><mi>x</mi><mn>0</mn></msub><mo>&#160;</mo></math>
      </d:informalequation>
      <d:para>
        We typically do not say that we are concerned with growth rate as <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> goes to
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#8734;</mo></math>
        and we simply write <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        .The notation can also be used to describe the behavior of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi></math> near some
        real number <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math> (often,
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>=</mo><mn>0</mn></math>
        ): we say
      </d:para>
      <d:informalequation>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>&#160;</mo><mo>&#160;</mo><mi>a</mi><mi>s</mi><mo>&#160;</mo><mi>x</mi><mo>&#8594;</mo><mi>a</mi></math>
      </d:informalequation>
      <d:para>
        if and only if there exist positive numbers <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#948;</mi></math> and
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> such
        that
      </d:para>
      <d:informalequation>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mo>|</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>|</mo><mo>&#8804;</mo><mi>K</mi><mo>|</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>|</mo><mo>&#160;</mo><mo>&#160;</mo><mi>f</mi><mi>o</mi><mi>r</mi><mo>&#160;</mo><mo>|</mo><mi>x</mi><mo>-</mo><mi>a</mi><mo>|</mo><mo>&lt;</mo><mi>&#948;</mi></math>
      </d:informalequation>
      <d:para>
        if <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        is non-zero for values of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> sufficiently
        close to <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math> , both of
        these definitions can be unified using the limit superior:
      </d:para>
      <d:informalequation>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>&#160;</mo><mo>&#160;</mo><mi>a</mi><mi>s</mi><mo>&#160;</mo><mi>x</mi><mo>&#8594;</mo><mi>a</mi></math>
      </d:informalequation>
      <d:para>
        if and only if:
      </d:para>
      <d:informalequation>
        <math xmlns="http://www.w3.org/1998/Math/MathML">
          <mrow>
	          <mstyle displaystyle="true">
		          <munder>
			          <mi>lim</mi>
			          <mrow>
				          <mi>x</mi>
				          <mo>&#x02192;</mo>
				          <mi>a</mi>
			          </mrow>
		          </munder>
	          </mstyle>
	          <mrow>
		          <mo rspace="0.3em" lspace="0em" stretchy="true" fence="true" form="prefix">&#x0007C;</mo>
		          <mfrac linethickness="1">
			          <mrow>
				          <mi>f</mi>
				          <mrow>
					          <mo form="prefix">(</mo>
					          <mi>x</mi>
					          <mo form="postfix">)</mo>
				          </mrow>
			          </mrow>
			          <mrow>
				          <mi>g</mi>
				          <mrow>
					          <mo form="prefix">(</mo>
					          <mi>x</mi>
					          <mo form="postfix">)</mo>
				          </mrow>
			          </mrow>
		          </mfrac>
		          <mo rspace="0em" lspace="0.3em" stretchy="true" fence="true" form="postfix">&#x0007C;</mo>
	          </mrow>
	          <mo>&#x0003C;</mo>
	          <mo>&#x0221E;</mo>
          </mrow>
        </math>
      </d:informalequation>
      <d:para>
        To explain how we compute <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></math>
        let us see an example. Consider a polynomial function with all positive
        coefficients. Say our polynomial is something like <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><msup><mi>x</mi><mi>n</mi></msup><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><msup><mi>x</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msup><mi>x</mi><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub></math>. We
        can very safely say
      </d:para>
      <d:informalequation>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>|</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>|</mo><mo>&#8804;</mo><mo>(</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><mo>)</mo><msup><mi>x</mi><mi>n</mi></msup><mo>&#160;</mo><mo>&#160;</mo><mo>&#8704;</mo><mo>&#160;</mo><mi>x</mi><mo>&#8805;</mo><mn>1</mn></math>
      </d:informalequation>
      <d:para>
        Therefore we can say <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mi>n</mi></msup><mo>)</mo></math>.
      </d:para>
      <d:sect3>
        <d:title>An Alternative Definition</d:title>
        <d:para>
          For two functions <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
          and <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
          and a constant <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>&#8712;</mo><msup><mi
          mathvariant="normal">&#8477;</mi><mo>+</mo></msup></math> <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
          if <math
          xmlns="http://www.w3.org/1998/Math/MathML"><munder><mi>lim</mi><mrow><mi>x</mi><mo>&#8594;</mo><mo>&#8734;</mo></mrow></munder><mfenced><mfrac><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mfenced><mo>=</mo><mi>K</mi></math>.
        </d:para>
      </d:sect3>
      <d:para>
        Complexity of algorithms form into various functions. I am presenting
        graphs of some common functions below for quick understanding. By looking
        at these graphs you can quickly deduce that which complexity fares well
        and which does not.
      </d:para>
      <d:figure>
        <d:title>Graphs of some common functions</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="../images/function_plot_cropped.png" align="center"/>
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
      <d:figure>
        <d:title>Graphs of some more common functions</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="../images/function_plot1_cropped.png" align="center" />
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
      <d:figure>
        <d:title>Graph of O(n!)</d:title>
        <d:mediaobject>
          <d:imageobject>
            <d:imagedata fileref="../images/factorial_cropped.png" align="center" />
          </d:imageobject>
        </d:mediaobject>
      </d:figure>
      <d:para>
        I am presenting a table for runtime of various complexities, looking at
        which you can appreciate the algorithms with better runtime.
      </d:para>
      <d:table frame="border" border="1" class="centered">
        <d:caption>
          Time for <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
          instructions on a <math
          xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>10</mn><mn>9</mn></msup></math>
          instructions/second computer.
        </d:caption>
        <d:colgroup align="center"/>
        <d:colgroup align="center"/>
        <d:colgroup align="center"/>
        <d:colgroup align="center"/>
        <d:colgroup align="center"/>
        <d:colgroup align="center"/>
        <d:thead>
          <d:tr>
            <d:th><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></d:th>
            <d:th><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi></math></d:th>
            <d:th><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><msub><mi>log</mi><mn>2</mn></msub><mi>x</mi></math></d:th>
            <d:th><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></math></d:th>
            <d:th><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup></math></d:th>
            <d:th><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mn>2</mn><mi>x</mi></msup></math></d:th>
          </d:tr>
        </d:thead>
        <d:tbody>
          <d:tr>
            <d:td>10</d:td>
            <d:td>.01 &#956;s</d:td>
            <d:td>.03 &#956;s</d:td>
            <d:td>.1 &#956;s</d:td>
            <d:td>1 &#956;s</d:td>
            <d:td>1 &#956;s</d:td>
          </d:tr>
          <d:tr>
            <d:td>20</d:td>
            <d:td>.02 &#956;s</d:td>
            <d:td>.09 &#956;s</d:td>
            <d:td>.4 &#956;s</d:td>
            <d:td>8 &#956;s</d:td>
            <d:td>1 ms</d:td>
          </d:tr>
          <d:tr>
            <d:td>30</d:td>
            <d:td>.03 &#956;s</d:td>
            <d:td>.15 &#956;s</d:td>
            <d:td>.9 &#956;s</d:td>
            <d:td>27 &#956;s</d:td>
            <d:td>1 s</d:td>
          </d:tr>
          <d:tr>
            <d:td>40</d:td>
            <d:td>.04 &#956;s</d:td>
            <d:td>.21 &#956;s</d:td>
            <d:td>1.6 &#956;s</d:td>
            <d:td>64 &#956;s</d:td>
            <d:td>18.3 min</d:td>
          </d:tr>
          <d:tr>
            <d:td>50</d:td>
            <d:td>.05 &#956;s</d:td>
            <d:td>.28 &#956;s</d:td>
            <d:td>2.5 &#956;s</d:td>
            <d:td>125 &#956;s</d:td>
            <d:td>13 d</d:td>
          </d:tr>
          <d:tr>
            <d:td>100</d:td>
            <d:td>.1 &#956;s</d:td>
            <d:td>.66 &#956;s</d:td>
            <d:td>10 &#956;s</d:td>
            <d:td>1 ms</d:td>
            <d:td>4*10<d:superscript>13</d:superscript> yrs</d:td>
          </d:tr>
          <d:tr>
            <d:td>1000</d:td>
            <d:td>1 &#956;s</d:td>
            <d:td>9.96 &#956;s</d:td>
            <d:td>1 ms</d:td>
            <d:td>1 s</d:td>
            <d:td>32*10<d:superscript>283</d:superscript> yrs</d:td>
          </d:tr>
          <d:tr>
            <d:td>10,000</d:td>
            <d:td>10 &#956;s</d:td>
            <d:td>130 &#956;s</d:td>
            <d:td>100 ms</d:td>
            <d:td>16.67 min</d:td>
            <d:td></d:td>
          </d:tr>
          <d:tr>
            <d:td>100,000</d:td>
            <d:td>100 &#956;s</d:td>
            <d:td>1.66 ms</d:td>
            <d:td>10 s</d:td>
            <d:td>11.57 days</d:td>
            <d:td></d:td>
          </d:tr>
          <d:tr>
            <d:td>1,000,000</d:td>
            <d:td>1 ms</d:td>
            <d:td>19.92 ms</d:td>
            <d:td>16.67 min</d:td>
            <d:td>31.71 yrs</d:td>
            <d:td></d:td>
          </d:tr>
        </d:tbody>
      </d:table>
      <d:para>
        The complexity of function <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>x</mi></msup></math>
        rises so 
        fast that it is already beyond the number of years sun is going to
        survive.
      </d:para>
      <d:para>
        As you can clearly see
        <d:inlineequation>
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>)</mo><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>&lt;</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&lt;</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>*</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>&lt;</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo><mo>&lt;</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo><mo>&lt;</mo><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>x</mi></msup><mo>)</mo><mo>&lt;</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>!</mo><mo>)</mo></math>
        </d:inlineequation>
      </d:para>
      <d:para>
        As <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi></math>-notation
        gives upper bound similarly <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#937;</mi></math>-notation
        gives lower bound. <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></math>
        means there exists two constants <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi></math> and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>n</mi><mn>0</mn></msub></math>
        such that
      </d:para>
      <d:informalequation>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&#8805;</mo><mi>L</mi><mo>|</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>|</mo><mo>&#160;</mo><mo>&#160;</mo><mo>&#8704;</mo><mo>&#160;</mo><mi>x</mi><mo>&gt;</mo><msub><mi>x</mi><mn>0</mn></msub></math>
      </d:informalequation>
      <d:para>
        Note that this is Knuth's definition
        for <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#937;</mi></math> not
        the Hardy-Littlewood definition. Knuth has commented on why he has
        changed this definition:
      </d:para>
      <d:blockquote>
        <d:attribution>D. E. Knuth</d:attribution>
        <d:para>
          Although I
          have changed Hardy and Littlewood's definition of <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#937;</mi></math>, I
          feel justified
          in doing so because their definition is by no means in wide use, and
          because there are other ways to say what they want to say in the
          comparatively rare cases when their definition
          applies.
        </d:para>
      </d:blockquote>
      <d:para>
        Hardy-Littlewood's version of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#937;</mi></math> is
        given below:
      </d:para>
      <d:informalequation>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>&#160;</mo><mo>(</mo><mi>x</mi><mo>&#8594;</mo><mo>&#8734;</mo><mo>)</mo><mo>&#160;</mo><mo>&#8660;</mo><mo>&#160;</mo><munder><mi>limsup</mi><mrow><mi>x</mi><mo>&#8594;</mo><mo>&#8734;</mo></mrow></munder><mfenced
            open="|"
            close="|"><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mfenced><mo>&gt;</mo><mn>0</mn></math>
      </d:informalequation>
      <d:para>
        If we want to write exact order of growth without being accurate about
        constant factors <math 
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi></math> and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> then we use
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#920;</mi></math>-notation.
      </d:para>
      <d:para>
        <d:inlineequation><math
                              xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#920;</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>&#8660;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math></d:inlineequation>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        implying <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#920;</mi></math>-notation
        gives both upper and lower bounds.
      </d:para>
      <d:para>
        Note that for an algorithm performing at a complexity of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>
        we can say that <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo></math>
        is its complexity as an approximation. It is allowed to represent a
        complexity at a worse notation but not a better notation. Just that
        the statement will be slightly inaccurate. The reason for this is that
        the function which has worse complexity is still and upper bound of the
        better function and thus our assumption of giving an upper bound holds
        true.
      </d:para>
      <d:para>
        If you know calculus and coordinate geometry then you would notice that a
        worse function has a higher rate of growth i.e. slope of the curve
        i.e. <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
        or <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>d</mi><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
        where <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>. For
        any higher value of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> the slope or
        rate of growth will eventually be higher for worse performing
        function. For example, for <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>
        that value of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> is 1 when
        compared with <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>. This
        value can be obtained by solving <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></math>
        for the two functions.
      </d:para>
      <d:para>
        In computer science for algorithm analysis we are almost always worried
        about big-<math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi></math> complexity
        because it gives upper bound i.e. for large set of input how the
        algorithm will behave. The problem with big-<math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi></math> notation is that even though it talks about two constants <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>0</mn></msub></math>
        and <math 
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> it does not
        give any hints about there values or how to compute them. It also does
        not put any restriction on the values of these constants not gives any
        guidelines when there are many such values.
      </d:para>
      <d:para>
        There is also space efficiency or memory efficiency. There are times when
        the devices we use do not have a lot of memory then we need to find
        algorithms which are efficient memory-wise. For example, there are two
        very good algorithms for sorting an array of values (or string) quick
        sort and merge sort. However, consider the case when we have less memory
        than the array then neither of these algorithms can be used. One of the
        sorting algorithms among many is external sort. This technique is old
        because in earlier devices memory was less and usually data to be sorted
        was more. Algorithms which were very important a few decades ago are now
        important merely for academic importance.
      </d:para>
      <d:para>
        In case you prefer graphs to mathematical functions to understand, below
        I present all three big notations.
        <d:figure>
          <d:title>Graphical representation of big-<math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi></math> notation</d:title>
          <d:mediaobject>
            <d:imageobject>
              <d:imagedata fileref="../images/big-o.png" align="center" />
            </d:imageobject>
          </d:mediaobject>
        </d:figure>
        <d:figure>
          <d:title>Graphical representation of big-<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#937;</mi></math> notation</d:title>
          <d:mediaobject>
            <d:imageobject>
              <d:imagedata fileref="../images/big-omega.png" align="center" />
            </d:imageobject>
          </d:mediaobject>
        </d:figure>
        <d:figure>
          <d:title>Graphical representation of big-<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#920;</mi></math> notation</d:title>
          <d:mediaobject>
            <d:imageobject>
              <d:imagedata fileref="../images/big-theta.png" align="center" />
            </d:imageobject>
          </d:mediaobject>
        </d:figure>
      </d:para>
    </d:sect2>
    <d:sect2>
      <d:title>An Example of Complexity Computation</d:title>
      <d:para>
        In an algorithm analysis we have to consider all operations although
        many times if the code is simple you can just see and guess the
        complexity. However, in case of complex code you will find it difficult
        to do that. For example consider the following code which computes sum
        of n numbers stored in an array.
      </d:para>
      <d:programlisting role="CLexer"><![CDATA[for(i=sum=0; i<n; ++i)
  sum += a[i];]]></d:programlisting>
      <d:para>
        First we have two initializations for <d:code>i</d:code> and
        <d:code>sum</d:code>. Let cost of assignment be <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mn>1</mn></msub></math>.
        Then <d:code>i</d:code> is incremented from <d:code>0</d:code> to
        <d:code>n-1</d:code>. Let cost of increment be <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mn>2</mn></msub></math>. Now
        There are <d:code>n</d:code> additions and <d:code>n</d:code> assignments
        for sum. Let cost of addition is <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mn>3</mn></msub></math>. So
        total cost is <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>*</mo><mo>(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>+</mo><msub><mi>C</mi><mn>3</mn></msub><mo>)</mo></math>. Thus
        total cost is <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mo>*</mo><msub><mi>C</mi><mn>1</mn></msub><mo>+</mo><mi>n</mi><mo>*</mo><msub><mi>C</mi><mn>2</mn></msub><mo>+</mo><mi>n</mi><mo>*</mo><mo>(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>+</mo><mi>C</mi><mo>+</mo><mn>3</mn><mo>)</mo></math>
        i.e. <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><mn>2</mn><mo>+</mo><mi>n</mi><mo>)</mo><msub><mi>C</mi><mn>1</mn></msub><mo>+</mo><mi>n</mi><mo>*</mo><msub><mi>C</mi><mn>2</mn></msub><mo>+</mo><mi>n</mi><mo>*</mo><msub><mi>C</mi><mn>3</mn></msub></math>.
        These constants <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mn>1</mn></msub></math>, <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mn>2</mn></msub></math> and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>C</mi><mn>3</mn></msub></math>
        can be measured in terms of clock cycles. Thus complexity is <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></math>.
      </d:para>
      <d:para>
        As you can guess if we have nested loops complexity wil increase in
        terms of power of n. However, the complexity may not increase exactly
        by integral power.
      </d:para>
    </d:sect2>
    <d:sect2>
      <d:title>Simplicity</d:title>
      <d:para>
        It is not enough for an algorithm to be efficient from the perspective
        of memory and time but it should also be simple enough to
        implement. For example, splay-trees are very good for maintaining fast
        search time. But the implementation is complex compared to a Red-Black
        tree or AVL-tree therefore they are usually not preferred. However,
        this is not the only reason. I will let you know more detail when we
        discuss trees in their own chapter. Thus, even <d:code>gcc</d:code>
        uses Red-Black trees as back-end storage medium for maps in STL.
      </d:para>
      <d:para>
        Similarly, dynamic perfect sorting is very good for large set of data
        but again it is rarely implemented because of complexity.
      </d:para>
    </d:sect2>
    <d:sect2>
      <d:title>More on Asymptotic Notations</d:title>
      <d:sect3>
        <d:title>Little o Notation</d:title>
        <d:para>
          The notation is written as <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mrow><mo
          form="prefix">(</mo><mi>x</mi><mo
          form="postfix">)</mo></mrow><mo>=</mo><mi>o</mi><mrow><mo
          form="prefix">(</mo><mi>g</mi><mo form="prefix">(</mo><mi>x</mi><mo
          form="postfix">)</mo><mo
          form="postfix">)</mo></mrow></mrow></math>. And in set notation it is
          <math
              xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&#8712;</mo><mi>o</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>. It
          means that <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
          grows faster than <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>. As <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>&#8594;</mo><mo>&#8734;</mo></math> for every positive constant <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#949;</mi></math> there exists a constant <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> such that
        </d:para>
        <d:informalequation>
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>|</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>|</mo><mo>&#8804;</mo><mi>&#1013;</mi><mo>|</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>|</mo><mo>&#160;</mo><mo>&#8704;</mo><mo>&#160;</mo><mi>x</mi><mo>&#8805;</mo><mi>N</mi></math>.
        </d:informalequation>
        <d:para>
          Note the difference between big-O and little-o. While for big-O we
          need at least one constant but for little-o it must hold true for all
          constants, however small. Thus, the constraints for little-o is
          stronger than big-O. This also implies a function which is big-O will
          be little-o but may not be other way around.
        </d:para>
        <d:para>
          If <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
          is nonzero, or at least becomes nonzero beyond a certain value of its
          variable, the relation <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>o</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
          is equivalent to
        </d:para>
        <d:informalequation>
          <math xmlns="http://www.w3.org/1998/Math/MathML"><munder><mi>lim</mi><mrow><mi>x</mi><mo>&#8594;</mo><mo>&#8734;</mo></mrow></munder><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac><mo>=</mo><mn>0</mn></math>.
        </d:informalequation>
      </d:sect3>
      <d:sect3>
        <d:title>Little <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#969;</mi></math>
        Notation</d:title>
        <d:para>
          Little-<math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#969;</mi></math>
          notation is the inverse of the <math 
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>o</mi></math>-notation
          i.e.,
          <d:informalequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&#8712;</mo><mi>o</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>&#8660;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#969;</mi><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
          </d:informalequation>
          i.e. 
        </d:para>
        <d:informalequation>
          <math
              xmlns="http://www.w3.org/1998/Math/MathML"><munder><mi>lim</mi><mrow><mi>x</mi><mo>&#8594;</mo><mo>&#8734;</mo></mrow></munder><mfrac><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac><mo>=</mo><mn>0</mn></math>.
        </d:informalequation>
      </d:sect3>
    </d:sect2>
  </d:sect1>
  <d:sect1>
    <d:title>Problems on Complexity</d:title>
    <d:para>
      For each of the following pairs of functions <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
      and <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>,
      either <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
      or <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>,
      but not both. Determine the case.
    </d:para>
    <d:orderedlist>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>-</mo><mi>x</mi><mo>+</mo><mn>7</mn><mo>)</mo><mo>/</mo><mn>2</mn><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>6</mn><mi>x</mi><mo>+</mo><mn>9</mn></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mn>2</mn><msqrt><mi>x</mi></msqrt><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mi>log</mi><mi>x</mi><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><msqrt><mi>x</mi></msqrt></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mi>log</mi><mi>x</mi><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><msqrt><mi>x</mi></msqrt><mo>/</mo><mn>2</mn></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mi>log</mi><mi>x</mi><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msqrt><mi>x</mi></msqrt></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>2</mn><mo>(</mo><mi>log</mi><mi>x</mi><msup><mo>)</mo><mn>2</mn></msup><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>log</mi><mi>x</mi><mo>+</mo><mn>1</mn></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>4</mn><mi>x</mi><mi>log</mi><mi>x</mi><mo>+</mo><mi>x</mi><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>-</mo><mi>x</mi><mo>)</mo><mo>/</mo><mn>2</mn></math>.
      </d:listitem>
    </d:orderedlist>
    <d:para>
      Which of the following cases are true and which are false?
    </d:para>
    <d:orderedlist continuation="continues">
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mi>O</mi><mo>(</mo><mn>1</mn><mo>.</mo><mn>4</mn><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>3</mn></msup><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mi>log</mi><mi>x</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi>x</mi><msqrt><mi>x</mi></msqrt><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mi>x</mi></msqrt><mo>=</mo><mi>O</mi><mo>(</mo><mi>log</mi><mi>x</mi><mo>)</mo></math>
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mi>x</mi><mo>=</mo><mi>O</mi><mo>(</mo><msqrt><mi>x</mi></msqrt><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>3</mn></msup><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>(</mo><mn>1</mn><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>/</mo><mi>x</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi>log</mi><mi>x</mi><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mi>x</mi><mo>=</mo><mi>O</mi><mo>(</mo><mn>1</mn><mo>/</mo><mi>x</mi><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mi>x</mi><mo>=</mo><mi>O</mi><mo>(</mo><mfrac><mn>1</mn><msqrt><mi>x</mi></msqrt></mfrac><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        If <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>~</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>,
        then <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#920;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        If <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#920;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>,
        then <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#920;</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>2</mn></msup><mo>(</mo><mn>1</mn><mo>+</mo><msqrt><mi>x</mi></msqrt><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>2</mn></msup><mo>(</mo><mn>1</mn><mo>+</mo><msqrt><mi>x</mi></msqrt><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mi>log</mi><mi>x</mi><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>2</mn></msup><mo>(</mo><mn>1</mn><mo>+</mo><msqrt><mi>x</mi></msqrt><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>x</mi><msqrt><mi>x</mi></msqrt><mo>+</mo><msqrt><mi>x</mi></msqrt><mo>)</mo></math>.
      </d:listitem>
    </d:orderedlist>
    <d:para>
      For following functions, find out whether <math
      xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>,</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>,</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#920;</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
      or none of these.
    </d:para>
    <d:orderedlist continuation="continues">
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>3</mn><mo>.</mo><mn>5</mn><msqrt><mi>x</mi></msqrt><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>log</mi><mi>x</mi><mo>+</mo><mn>7</mn></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mroot><mi>x</mi><mn>3</mn></mroot><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>-</mo><mn>7</mn><mi>x</mi></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mroot><mi>x</mi><mn>3</mn></mroot><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mi>log</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mfrac><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>-</mo><mn>3</mn></mrow><mrow><mn>3</mn><mo>+</mo><msup><mn>2</mn><mrow><mo>-</mo><mi>x</mi></mrow></msup></mrow></mfrac><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mn>5</mn></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mn>3</mn><mi>x</mi></msup><mo>-</mo><msup><mi>x</mi><mn>3</mn></msup><mo>,</mo><mo>&#160;</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mi>x</mi></math>.
      </d:listitem>
    </d:orderedlist>
    <d:para>
      Prove the following equalities.
    </d:para>
    <d:orderedlist continuation="continues">
      <d:listitem>
        <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><mi>x</mi><mo>+</mo><mn>3</mn><msup><mo>)</mo><mn>2</mn></msup><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        For all <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>&#8805;</mo><mn>1</mn></math>
        and all <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mn>0</mn></msub><mo>,</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>a</mi><mrow><mi>x</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>a</mi><mi>x</mi></msub><mo>&#8712;</mo><mi
        mathvariant="normal">&#8477;</mi></math>,
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mi>x</mi></msub><msup><mi>x</mi><mi>x</mi></msup><mo>+</mo><msub><mi>a</mi><mrow><mi>x</mi><mo>-</mo><mn>1</mn></mrow></msub><msup><mi>x</mi><mrow><mi>x</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mi>x</mi></msup><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#8968;</mo><mi>log</mi><mi>x</mi><mo>&#8969;</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mi>x</mi><mo>&#8970;</mo><mi>log</mi><mi>x</mi><mo>&#8971;</mo><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>3</mn></msup><mo>-</mo><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mi>&#920;</mi><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mn>7</mn><mi>x</mi><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>x</mi></msup><mo>=</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>!</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mrow><mi>log</mi><mi>x</mi></mrow></msup><mo>=</mo><mi>O</mi><mo>(</mo><mo>(</mo><mi>log</mi><mi>x</mi><msup><mo>)</mo><mi>x</mi></msup><mo>)</mo><mo>?</mo></math>
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mrow><mi>log</mi><mi>x</mi></mrow></msup><mo>=</mo><mi>&#937;</mi><mo>(</mo><mo>(</mo><mi>log</mi><mi>x</mi><msup><mo>)</mo><mi>x</mi></msup><mo>)</mo><mo>?</mo></math>
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mrow><mi>log</mi><mi>log</mi><mi>log</mi><mi>x</mi></mrow></msup><mo>=</mo><mi>O</mi><mo>(</mo><mi>log</mi><mi>x</mi><mo>!</mo><mo>)</mo></math>
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mrow><mi>log</mi><mi>log</mi><mi>log</mi><mi>x</mi></mrow></msup><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>log</mi><mi>x</mi><mo>!</mo><mo>)</mo><mo>)</mo></math>
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mfenced><msup><mfenced><mfrac><mi>x</mi><mrow><mi>log</mi><mi>log</mi><mi>x</mi></mrow></mfrac></mfenced><mfrac><mn>1</mn><mn>2</mn></mfrac></msup></mfenced><mo>=</mo><mi>O</mi><mo>(</mo><mo>&#8970;</mo><msqrt><mi>x</mi></msqrt><mo>)</mo><mo>?</mo></math>
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><msup><mn>2</mn><mfenced><mrow><mn>1</mn><mo>+</mo><mi>O</mi><mfenced><mfrac><mn>1</mn><mi>x</mi></mfrac></mfenced></mrow></mfenced></msup><mn>2</mn></msup><mo>=</mo><mn>2</mn><mo>+</mo><mi>O</mi><mfenced><mfrac><mn>1</mn><mi>x</mi></mfrac></mfenced><mo>?</mo></math>
      </d:listitem>
    </d:orderedlist>
    <d:para>
      Following questions are on properties of big-O notation. Prove or
      disprove the following statements.
    </d:para>
    <d:orderedlist continuation="continues">
      <d:listitem>
        If <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>,
        <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        If <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>,
        <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        If <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>,
        <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>,</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        If <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>,
        <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>m</mi><mi>i</mi><mi>x</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>,</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
            <d:listitem>
        If <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>,
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>*</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>*</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        If <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>,
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>*</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>*</mo><msub><mi>g</mi><mn>2</mn></msub><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        For all functions <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        either <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        or <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        For all <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&gt;</mo><mn>0</mn></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&gt;</mo><mn>0</mn></math>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#160;</mo><mo>&#8704;</mo><mi>x</mi></math>,
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>+</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><msup><mo>)</mo><mi>&#945;</mi></msup><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><msup><mo>)</mo><mi>&#945;</mi></msup><mo>&#160;</mo><mo>&#8704;</mo><mi>&#945;</mi><mo>&#8712;</mo><msup><mi
            mathvariant="normal">&#8477;</mi><mo>+</mo></msup></math>.
      </d:listitem>
    </d:orderedlist>
  </d:sect1>
  <d:sect1>
    <d:title>Solutions</d:title>
    <d:orderedlist>
      <d:listitem>
        Clearly, <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>. Thus,
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        gives an upper bound on <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>,
        hence, <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
        <d:para>
          Using differentiation of functions, <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>d</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mo>d</mo><mi>x</mi></mrow></mfrac><mo>=</mo><mn>2</mn><mi>x</mi><mo>&#160;</mo><mo>-</mo><mn>1</mn></math>
          and <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>d</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mo>d</mo><mi>x</mi></mrow></mfrac><mo>=</mo><mn>6</mn></math>. If
          we equate the two slopes of curves then we have, <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>x</mi><mo>-</mo><mn>1</mn><mo>=</mo><mn>6</mn></math>,
          implying that after <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>=</mo><mn>3</mn><mo>.</mo><mn>5</mn></math>
          the slope of <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
          will be more than that of <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
          and it is monotonically increasing making <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
          upper bound, resulting in answer.
        </d:para>
      </d:listitem>
      <d:listitem>
        You can follow the two methods shown in previous problem to reach the
        answer, which is <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mi>log</mi><mi>x</mi></math>
        is <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        because <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mi>x</mi></math>
        grows slower as compared to <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math>. Thus,
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        The order of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> is
        cancelled as it is present in both the functions and the constant
        factor of half does not matter. Thus, for the
        evaluation purpose we can treat them as <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>log</mi><mi>x</mi></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msqrt><mi>x</mi></msqrt></math>. The
        differentiation of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mi>x</mi></math>
        gives us <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mn>1</mn><mi>x</mi></mfrac></math>
        and that of <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mi>x</mi></msqrt></math>
        is <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mn>1</mn><mrow><mn>2</mn><msqrt><mi>x</mi></msqrt></mrow></mfrac></math>. Again
        the constant does not matter and former grows slower than latter thus
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        Following from previous problem you can arrive at the answer, <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        Following similarly as previous problems, <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        Following similarly as previous problems, <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        Constant factors do not matter. Clearly <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo></math>
        as <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>3</mn></msup></math>
        grows faster than <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>2</mn></msup></math>
        and thus the statement is true.
      </d:listitem>
      <d:listitem>
        False.
      </d:listitem>
      <d:listitem>
        True.
      </d:listitem>
      <d:listitem>
        False.
      </d:listitem>
      <d:listitem>
        True.
      </d:listitem>
      <d:listitem>
        True.
      </d:listitem>
      <d:listitem>
        True.
      </d:listitem>
      <d:listitem>False.</d:listitem>
      <d:listitem>False.</d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>~</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>&#8658;</mo><munder><mi>lim</mi><mrow><mi>x</mi><mo>&#8594;</mo><mo>&#8734;</mo></mrow></munder><mfrac><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac><mo>=</mo><mn>1</mn></math>. Thus,
        the availability of constants is there which make the statement true.
      </d:listitem>
      <d:listitem>
        We know that <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#920;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        if <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        is <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>
        and <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        is <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#937;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
        <d:para>
          Thus, by flipping the constant for the definition we have the
          statement as true.
        </d:para>
      </d:listitem>
      <d:listitem>False.</d:listitem>
      <d:listitem>False.</d:listitem>
      <d:listitem>False.</d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:indexterm>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:indexterm>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>&#937;</mi><mo>(</mo><mi>g</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        Given, <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><mi>x</mi><mo>+</mo><mn>3</mn><msup><mo>)</mo><mn>2</mn></msup><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>
        <d:para>
          <math
              xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#8658;</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>6</mn><mi>x</mi><mo>+</mo><mn>9</mn><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>
        </d:para>
        <d:para>
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#8658;</mo><mo>(</mo><mi>x</mi><mo>+</mo><mn>3</mn><msup><mo>)</mo><mn>2</mn></msup><mo>&#8804;</mo><mn>17</mn><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo><mo>&#160;</mo><mo>&#8704;</mo><mi>x</mi><mo>&#8805;</mo><mn>1</mn></math>
        </d:para>
        <d:para>
          Hence, proven.
        </d:para>
      </d:listitem>
      <d:listitem>
        Given, <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mi>x</mi></msub><msup><mi>x</mi><mi>x</mi></msup><mo>+</mo><msub><mi>a</mi><mrow><mi>x</mi><mo>-</mo><mn>1</mn></mrow></msub><msup><mi>x</mi><mrow><mi>x</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mi>x</mi></msup><mo>)</mo></math>
        <d:para>
          <math
              xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#8658;</mo><msub><mi>a</mi><mi>x</mi></msub><msup><mi>x</mi><mi>x</mi></msup><mo>+</mo><msub><mi>a</mi><mrow><mi>x</mi><mo>-</mo><mn>1</mn></mrow></msub><msup><mi>x</mi><mrow><mi>x</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub><mo>&#8804;</mo><mo>(</mo><msub><mi>a</mi><mi>x</mi></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>x</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>0</mn></msub><mo>)</mo><msup><mi>x</mi><mi>x</mi></msup><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mi>x</mi></msup><mo>)</mo></math>.
        </d:para>
        <d:para>
          Hence, proven.
        </d:para>
      </d:listitem>
      <d:listitem>
        <d:para>
          In this and the next problem I have not found the constant and
          limiting value of <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math> thus
          these are not an accurate answers. It has been left as an exercise to
          the reader to find those.
        </d:para>        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#8968;</mo><mi>log</mi><mi>x</mi><mo>&#8969;</mo><mo>&#8804;</mo><mi>log</mi><mi>x</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#8970;</mo><mi>log</mi><mi>x</mi><mo>&#8971;</mo><mo>&#8804;</mo><mi>log</mi><mi>x</mi><mo>=</mo><mi>O</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>
        <d:para>
          <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#8658;</mo><mn>6</mn><mi>x</mi><mo>&#8970;</mo><mi>log</mi><mi>x</mi><mo>&#8971;</mo><mo>&#8804;</mo><mn>6</mn><mi>x</mi><mi>log</mi><mi>x</mi><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>)</mo></math>
        </d:para>
      </d:listitem>
      <d:listitem>
        <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>&#8804;</mo><msup><mi>x</mi><mn>2</mn></msup><mo>&#160;</mo><mo>&#8704;</mo><mi>x</mi><mo>&#8805;</mo><mn>1</mn></math>
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>3</mn></msup><mo>-</mo><msup><mi>x</mi><mn>2</mn></msup><mo>&#8804;</mo><msup><mi>x</mi><mn>3</mn></msup><mo>&#160;</mo><mo>&#8704;</mo><mi>x</mi><mo>&#8805;</mo><mn>0</mn></math>
        and thus, <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>3</mn></msup><mo>-</mo><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mi>O</mi><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo></math>.
        <d:para>
          And, <math
          xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>3</mn></msup><mo>-</mo><msup><mi>x</mi><mn>2</mn></msup><mo>&#8805;</mo><mo>.</mo><mn>1</mn><msup><mi>x</mi><mn>3</mn></msup><mo>&#160;</mo><mo>&#8704;</mo><mi>x</mi><mo>&#8805;</mo><mn>2</mn></math>,
          thus, <math
        xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>x</mi><mn>3</mn></msup><mo>-</mo><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mi>&#937;</mi><mo>(</mo><msup><mi>x</mi><mn>3</mn></msup><mo>)</mo></math>.
        </d:para>
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mn>7</mn><mi>x</mi><mo>&#8804;</mo><msup><mi>x</mi><mn>3</mn></msup><mo>&#160;</mo><mo>&#8704;</mo><mi>x</mi><mo>&#8805;</mo><mn>3</mn></math>
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>x</mi></msup><mo>&#8804;</mo><mi>x</mi><mo>!</mo><mo>&#160;</mo><mo>&#8704;</mo><mi>x</mi><mo>&#8805;</mo><mn>4</mn></math>
      </d:listitem>
      <d:listitem>
        Taking logarithm of both functions, we have
        <d:para>
          <math
              xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mi>x</mi><mi>log</mi><mi>x</mi><mo>=</mo><mi>x</mi><mi>log</mi><mi>log</mi><mi>x</mi></math>. Clearly,
          the statement is true as right hand side will grow at a faster
          speed.
        </d:para>
      </d:listitem>
      <d:listitem>
        As follows from previous solution it is false.
      </d:listitem>
      <d:listitem>
        <math
            xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mi>x</mi><mo>!</mo><mo>=</mo><mi>log</mi><mo>(</mo><mi>x</mi><mo>*</mo><mo>(</mo><mi>x</mi><mo>-</mo><mn>1</mn><mo>)</mo><mo>*</mo><mo>(</mo><mi>x</mi><mo>-</mo><mn>2</mn><mo>)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>*</mo><mn>3</mn><mo>*</mo><mn>2</mn><mo>*</mo><mn>1</mn><mo>)</mo></math>
        <d:para>
          <math
              xmlns="http://www.w3.org/1998/Math/MathML"><mi>log</mi><mi>x</mi><mo>!</mo><mo>&lt;</mo><mi>x</mi><mi>log</mi><mi>x</mi></math>.
        </d:para>
        <d:para>
          By taking logarithm of this new result we find that the statement is true.
        </d:para>
      </d:listitem>
      <d:listitem>
        False.
      </d:listitem>
    </d:orderedlist>
    <d:para>
      Remaining problems are left as an exercise.
    </d:para>
  </d:sect1>
</d:chapter>
