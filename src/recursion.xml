<d:chapter version="5.0" xmlns:d="http://docbook.org/ns/docbook"
           xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink"
           xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <?xml-stylesheet href="../css/style.css" type="text/css"?>
  <?dbhtml filename="recursion/index.html" ?>
  <d:title>Recursion</d:title>
  <d:para>
    In this chapter we will study recursion. Recursion is such a powerful
    concept that it requires its own chapter. Usually, beginners find it hard
    to understand recursion. We will study several problems and their solutions
    to foster the concept of recursion. We will also study advantages and
    disadvantages of recursion. I have already discussed recursion in small
    detail <d:link xlink:href="/c/func/#idp51865936">here</d:link>. Usually,
    beginners do not understand recursion because they do not understand how
    the stack(not the data structure but the stack of a process in memory)
    works. Once you understand how it works it is very easy to understand
    recursion. I will treat recursion in much greater depth here than what was
    presented in C programming book.
  </d:para>
  <d:para>
    The power of recursion can be understood by following quote:
    <d:blockquote>
      <d:attribution>
          NK
      </d:attribution>
      <d:para>
        The power of recursion evidently lies in the possibility of defining an
        infinite set of objects by a finite statement. In the same manner, an
        infinite number of computations can be described by a finite recursive
        program, even if this program contains no explicit repetitions.
      </d:para>
    </d:blockquote>
  </d:para>
  <d:para>
    Formally, we can say that a definition, which defines an object in terms of
    simpler case of itself is recursive definition. In C or any other
    programming language for that matter, recursion is the concept
    of a function calling itself. When a repeated operation has to be preformed
    over a variable, recursion can be used. Recursion simplifies the code a
    lot. Typically there is always a more effective iterative solutions are
    available but there are certain cases where recursion is always better than
    iteration. For example, traversal of trees where iteration is not so
    effective as compared to recursion. For beginners it is hard to understand
    recursion but once you understand it then it is not that hard to
    understand. A classic example is that of factorial calculation which would
    serve as base of the entire concept. The formula for factorial is given by
    <math xmlns="http://www.w3.org/1998/Math/MathML"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>!</mo><mo>=</mo><munderover><mo>&#x220F;</mo><mrow
          class="MJX-TeXAtom-ORD"><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>k</mi></math>
    and recursive definition of factorial is given by:
    <d:inlineequation>
      <mml:math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
        <mml:mtable columnalign="right left" rowspacing="3pt" columnspacing="0.278em">
          <mml:mtr>
            <mml:mtd>
              <mml:mi>n</mml:mi>
              <mml:mo>!</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mfenced open="{" close="">
                <mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em">
                  <mml:mtr>
                    <mml:mtd>
                      <mml:mn>1</mml:mn>
                    </mml:mtd>
                    <mml:mtd>
                      <mml:mspace width="1em" />
                      <mml:mtext>if n=0</mml:mtext>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi>n</mml:mi>
                      <mml:mo>&#x2212;<!-- − --></mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>!</mml:mo>
                      <mml:mo>&#215;<!-- ∗ --></mml:mo>
                      <mml:mi>n</mml:mi>
                    </mml:mtd>
                    <mml:mtd>
                      <mml:mspace width="1em" />
                      <mml:mtext>if n&gt;0</mml:mtext>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
              </mml:mfenced>
            </mml:mtd>
          </mml:mtr>
        </mml:mtable>
      </mml:math>
    </d:inlineequation>
  </d:para>
  <d:para>
        In case you do not understand the formula given below is expansion:
  </d:para>
  <d:informalequation>
    <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn><mo>!</mo><mo>=</mo><mn>1</mn><mo>!</mo><mo>=</mo><mn>1</mn></math>
  </d:informalequation>
  <d:informalequation>
    <math
        xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>!</mo><mo>=</mo><msubsup><mo>&#8719;</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>=</mo><mi>n</mi><mo>&#215;</mo><mo>(</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>)</mo><mo>&#215;</mo><mo>(</mo><mi>n</mi><mo>-</mo><mn>2</mn><mo>)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mn>3</mn><mo>&#215;</mo><mn>2</mn><mo>&#215;</mo><mn>1</mn></math> 
  </d:informalequation>
  <d:para>
    However, note that last two equations are not recursive. Rather the one
    given in terms of <math
    xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>)</mo><mo>!</mo></math>
    is recursive because it defines factorial in terms of a factorial in a
    simplified form.
  </d:para>
  <d:para>
    A recursive definition usually have one or more <d:emphasis
    role="italic">base cases</d:emphasis>, which produce result without causing
    recurrence for one or more set of inputs in a trivial fashion. Obviously,
    recursive algorithm also have <d:emphasis role="italic">recursive
    cases</d:emphasis>, where the algorithm recurs i.e. calls itself. For
    example, for factorial definition the base case would be
    <d:inlineequation>
      <math xmlns="http://www.w3.org/1998/Math/MathML">
        <mrow>
          <mn>0</mn>
          <mo>!</mo>
          <mo>=</mo>
          <mn>1</mn>
        </mrow>
      </math>
    </d:inlineequation>.
    The recursive case for factorial is
    <d:inlineequation>
      <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>(</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>)</mo><mo>!</mo></math>
    </d:inlineequation>
     Note that you have to be very careful when writing
    recursive algorithms in any structured language because the stack is
    limited and deep recursion will cause stack overflow. However, there are
    techniques like tail recursion described below which allows you to do deep
    recursion. Usually, base cases are when the recursive algorithm terminates
    and thus, these are called <d:emphasis role="italic">terminating
    cases.</d:emphasis>
  </d:para>
  <d:para>
    Sometimes you may not really have a terminating or base case. For example,
    evaluation of
    <d:inlineequation>
      <math
          xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi><mi>x</mi></msup><mo>=</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo>+</mo><mfrac><msup><mi>x</mi><mn>2</mn></msup><mrow><mn>2</mn><mo>!</mo></mrow></mfrac><mo>+</mo><mfrac><msup><mi>x</mi><mn>3</mn></msup><mrow><mn>3</mn><mo>!</mo></mrow></mfrac><mo>+</mo><mo>&#8230;</mo></math>
    </d:inlineequation>
    or 
    <d:inlineequation>
      <math
          xmlns="http://www.w3.org/1998/Math/MathML"><mi>c</mi><mi>o</mi><mi>s</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>1</mn><mo>-</mo><mi>x</mi><mo>+</mo><mfrac><msup><mi>x</mi><mn>2</mn></msup><mrow><mn>2</mn><mo>!</mo></mrow></mfrac><mo>-</mo><mfrac><msup><mi>x</mi><mn>3</mn></msup><mrow><mn>3</mn><mo>!</mo></mrow></mfrac><mo>+</mo><mo>&#8230;</mo><mo>(</mo><mo>-</mo><mn>1</mn><msup><mo>)</mo><mi>n</mi></msup><mfrac><msup><mi>x</mi><mi>n</mi></msup><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><mo>&#8230;</mo></math>
    </d:inlineequation>
    does not really have a base case. For evaluation of such infinite series
    you have to settle on an error constant usually denoted by
    <d:inlineequation><math
                          xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#8712;</mo></math></d:inlineequation>
    up to which you compute the series and then you stop. Usually if the
    constant <d:inlineequation><math
    xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#949;</mo></math></d:inlineequation>
    is below six significant digits for <d:code>float</d:code> and twelve for
    <d:code>double</d:code> then you should stop calculation as that is the
    maximum resolution you will get. The constant factor <d:inlineequation><math
    xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#949;</mo></math></d:inlineequation>
    will determine the terminating case for such a series.
  </d:para>
  <d:sect1>
    <d:title>Types of Recursion</d:title>
    <d:sect2>
      <d:title>Single and Multiple Recursions</d:title>
      <d:para>
        Recursions involving single references are known as <d:emphasis
        role="italic">single recursion</d:emphasis> and those involving
        multiple references are known as <d:emphasis role="italic">multiple
        recursion.</d:emphasis> For example, the factorial definition which we
        have seen is a case of single recursion. An example of multiple
        recursion is Fibonacci sequence. Mathematically an nth Fibonacci number
        in sequence is given by <d:inlineequation><math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mi>n</mi></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub></math></d:inlineequation>
        while the first two numbers are given by <d:inlineequation><math
        xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><msub><mi>F</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn></math></d:inlineequation>. Since
        the recursion involves two simpler references that is why we call it
        multiple reference. Another such example would be Ackermann's
        function. Ackermann's function is given by 
        <d:informalequation>
          <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
            <mi>A</mi>
            <mo stretchy="false">(</mo>
            <mi>m</mi>
            <mo>,</mo>
            <mi>n</mi>
            <mo stretchy="false">)</mo>
            <mo>=</mo>
            <mrow>
              <mfenced open="{" close="">
              <mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false">
                <mtr>
                  <mtd>
                    <mi>n</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mtd>
                  <mtd>
                    <mstyle displaystyle="false" scriptlevel="0">
                      <mtext>if&#xA0;</mtext>
                    </mstyle>
                    <mi>m</mi>
                    <mo>=</mo>
                    <mn>0</mn>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd>
                    <mi>A</mi>
                    <mo stretchy="false">(</mo>
                    <mi>m</mi>
                    <mo>&#x2212;<!-- − --></mo>
                    <mn>1</mn>
                    <mo>,</mo>
                    <mn>1</mn>
                    <mo stretchy="false">)</mo>
                  </mtd>
                  <mtd>
                    <mstyle displaystyle="false" scriptlevel="0">
                      <mtext>if&#xA0;</mtext>
                    </mstyle>
                    <mi>m</mi>
                    <mo>&gt;</mo>
                    <mn>0</mn>
                    <mstyle displaystyle="false" scriptlevel="0">
                      <mtext>&#xA0;and&#xA0;</mtext>
                    </mstyle>
                    <mi>n</mi>
                    <mo>=</mo>
                    <mn>0</mn>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd>
                    <mi>A</mi>
                    <mo stretchy="false">(</mo>
                    <mi>m</mi>
                    <mo>&#x2212;<!-- − --></mo>
                    <mn>1</mn>
                    <mo>,</mo>
                    <mi>A</mi>
                    <mo stretchy="false">(</mo>
                    <mi>m</mi>
                    <mo>,</mo>
                    <mi>n</mi>
                    <mo>&#x2212;<!-- − --></mo>
                    <mn>1</mn>
                    <mo stretchy="false">)</mo>
                    <mo stretchy="false">)</mo>
                  </mtd>
                  <mtd>
                    <mstyle displaystyle="false" scriptlevel="0">
                      <mtext>if&#xA0;</mtext>
                    </mstyle>
                    <mi>m</mi>
                    <mo>&gt;</mo>
                    <mn>0</mn>
                    <mstyle displaystyle="false" scriptlevel="0">
                      <mtext>&#xA0;and&#xA0;</mtext>
                    </mstyle>
                    <mi>n</mi>
                    <mo>&gt;</mo>
                    <mn>0.</mn>
                  </mtd>
                </mtr>
              </mtable>
              </mfenced>
              <mo fence="true" stretchy="true"></mo>
            </mrow>
          </math>
        </d:informalequation>
        Clearly, second and third cases of Ackermann's function show that it is
        a function having multiple recursion. One more important example of
        multiple recursion is traversal of binary tree in all three ways
        i.e. in-order, pre-order and post-order. Similarly, depth-first
        traversal of a graph is also a classic example of recursion. We will
        not see these last two here but rather in their own respective chapters
        of trees and graphs.
      </d:para>
      <d:para>
        Sometimes, it is possible to convert a multiple recursion algorithm to
        single recursion version. For example, a naive implementation of
        Fibonacci sequence shown above will be a case of multiple recursion but
        we can save two numbers and generate next Fibonacci number and pass
        it along with the previous number to the next iteration which will
        cause multiple recursion to become single recursion and will also allow
        us to do tail recursion. When we do this it becomes a case of
        corecursion. Similarly, binary tree can be traversed using extra
        storage iteratively or you can use threaded binary tree to eliminate
        the need of that extra storage.
      </d:para>
    </d:sect2>
    <d:sect2>
      <d:title>Indirect Recursion</d:title>
      <d:para>
        The examples which we have seen are cases of <d:emphasis
        role="italic">direct recursion</d:emphasis>. In direct recursion a
        function calls itself. However, if is quite possible for two functions
        to call each other. When such calls happen then the functions are
        known as demonstrating <d:emphasis role="italic">indirect
        recursion</d:emphasis> or <d:emphasis role="italic">mutual
        recursion</d:emphasis>. It is quite possible that a function
        <d:code>f</d:code> calls another function <d:code>g</d:code> and then
        <d:code>g</d:code> calls <d:code>f</d:code> again. Chains of more than
        2 functions is also possible. For example, a function
        <d:code>f1</d:code> calls functions <d:code>f2</d:code> which in turn
        calls <d:code>f3</d:code> and then it calls <d:code>f1</d:code>.
      </d:para>
      <d:para>
        Two very good examples of indirect or mutual recursion are recursive
        descent parsers and finite state machine implementation. For a
        recursive descent parser each rule of the grammar can be implemented as
        a function and these functions can call each other. A finite state
        machine's individual states can be implemented by a separate function
        and while the states keep changing these functions can call each other
        forming a case of indirect recursion i.e. mutual recursion.
      </d:para>
    </d:sect2>
    <d:sect2>
      <d:title>Anonymous Recursion</d:title>
      <d:para>
        Our programming language is C and in ISO C11(as of this writing. It may
        be part of a future specification with something like block of Obj-C.)
        this does not happen but I am giving this for the sake of completeness
        of discussion of recursion. Usually functions recurse by calling
        themselves by name. But in certain languages there are functions known
        as anonymous functions or lambdas which do not have a name. When such
        functions recurse then it is known as <d:emphasis
        role="italic">anonymous recursion</d:emphasis>. However, untill I give
        C++ examples you will not see this in action in this book.
      </d:para>
    </d:sect2>
    <d:sect2>
      <d:title>Structured and Generative Recursion</d:title>
      <d:para>
        A classification has been made by authors on how a piece of data is
        generated and used by certain authors. There are two types of such
        categorization. First is structured and second is generative.
      </d:para>
      <d:blockquote>
        <d:attribution>
            MFRBFMFSK
        </d:attribution>
        <d:para>
          [Functions that consume structured data] typically decompose their
          arguments into their immediate structural components and then process
          those components. If one of the immediate components belongs to the
          same class of data as the input, the function is recursive. For that
          reason, we refer to these functions as (STRUCTURALLY) RECURSIVE
          FUNCTIONS.
        </d:para>
      </d:blockquote>
      <d:para>
        Thus a critical observation which we can have from this definition is
        that the type of argument is a simpler form of original input following
        our original definition of recursion. For example, parsing an XML
        document or a JSON document, any kind of tree traversal will fall in
        this category. Even factorial or single recursive version of Fibonacci
        sequence generation will fall in this category.
      </d:para>
      <d:para>
        The second category is defined as:
      </d:para>
      <d:blockquote>
        <d:attribution>
            MF
        </d:attribution>
        <d:para>
          Many well-known recursive algorithms generate an entirely new piece
          of data from the given data and recur on it. HtDP (<d:link
          xlink:href="http://www.htdp.org">How To Design 
          Programs</d:link>) refers to this kind as generative recursion. Examples of
          generative recursion include: gcd, quicksort, binary search,
          mergesort, Newton's method, fractals, and adaptive integration.
        </d:para>
      </d:blockquote>
      <d:para>
        The critical difference between these two types of recursion is how
        they terminate. Where it is very easy to prove the termination of
        structurally recursive functions, it is much harder to do so for
        generative recursions. The guarantees of simplification of data in
        generative recursion is harder to guess. When you want to give a
        mathematical proof for structurally recursive function the proof is
        easier to give because the complexity decreases uniformly, usually but
        it may be non-uniform for generative recursion and thus, making it
        harder to give a proof.
      </d:para>
    </d:sect2>
  </d:sect1>
  <d:sect1>
    <d:title>Tail Recursion</d:title>
    <d:para>
      Functional languages usually do not have loops. In such languages a
      loop is written using recursion. For example, consider the following
      loop which prints all positing integers for data type <d:code>unsigned
      long</d:code>.
    </d:para>
    <d:programlisting role="CLexer"><![CDATA[#include <stdio.h>
#include <limits.h>

int main()
{
  for(unsigned long i=0; i<=ULONG_MAX; ++i)
    printf("%lu\n", i);

  return 0;
}]]></d:programlisting>
    <d:para>
      If you observe this simple program then it start printing the sequence
      0,1 ,2 till <d:code>UINT_MAX</d:code> is reached and then it will wrap
      around and <d:code>i</d:code> will become zero and loop will
      terminate. This simple loop can be implemented using recursion as shown
      below:
    </d:para>
    <d:programlisting role="CLexer"><![CDATA[#include <stdio.h>
#include <limits.h>

void f(unsigned long i)
{
  if(i == ULONG_MAX) {
    printf("%lu\n", i);
    return;
  }

  printf("%lu\n", i);
  f(i + 1);
}

int main()
{
  f(0);

  return 0;
}]]></d:programlisting>
    <d:para>
      If I compiler this program using the command <d:code>gcc -Wall -std=c99
      -pedantic test.c</d:code> then it causes stack overflow and terminates at
      a value of 261938 for <d:code>i</d:code>. The reason is simple is and
      that is it creates a lot of stack frames which is limited by
      <d:code>ulimit</d:code>. I can make my stack size more than its current
      valeu of 8MB but that is not the solution because even with all the RAM
      i.e. 8GB on my computer that willl be exhausted by this code. Now, the
      question is how do we overcome this problem. The short answer is that you
      add <d:code>-O2</d:code> to compiler for compilation making the command
      <d:code>gcc -Wall -std=c99 -pedantic test.c</d:code>. This will make code
      work. The long answer is that when you pass <d:code>-O2</d:code> flag to
      compiler then it does tail recursion optimization. Before we go in detail
      about tail recursion optimization let us look at assembly produced by the
      steps <d:code>gcc -Wall -std=c99 -pedantic -c test.c</d:code> and
      <d:code>objdump -d test.o</d:code> respectively:
    </d:para>
    <d:programlisting role="ALexer"><![CDATA[test.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <f>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 83 7d f8 ff       	cmpq   $0xffffffffffffffff,-0x8(%rbp)
  11:	75 18                	jne    2b <f+0x2b>
  13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  17:	48 89 c6             	mov    %rax,%rsi
  1a:	bf 00 00 00 00       	mov    $0x0,%edi
  1f:	b8 00 00 00 00       	mov    $0x0,%eax
  24:	e8 00 00 00 00       	callq  29 <f+0x29>
  29:	eb 26                	jmp    51 <f+0x51>
  2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2f:	48 89 c6             	mov    %rax,%rsi
  32:	bf 00 00 00 00       	mov    $0x0,%edi
  37:	b8 00 00 00 00       	mov    $0x0,%eax
  3c:	e8 00 00 00 00       	callq  41 <f+0x41>
  41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  45:	48 83 c0 01          	add    $0x1,%rax
  49:	48 89 c7             	mov    %rax,%rdi
  4c:	e8 00 00 00 00       	callq  51 <f+0x51>
  51:	c9                   	leaveq 
  52:	c3                   	retq   

0000000000000053 <main>:
  53:	55                   	push   %rbp
  54:	48 89 e5             	mov    %rsp,%rbp
  57:	bf 00 00 00 00       	mov    $0x0,%edi
  5c:	e8 00 00 00 00       	callq  61 <main+0xe>
  61:	b8 00 00 00 00       	mov    $0x0,%eax
  66:	5d                   	pop    %rbp
  67:	c3                   	retq]]></d:programlisting>
    <d:para>
      and the counterpart produced by <d:code>gcc -Wall -std=c99 -pedantic -O2
      -c test.c</d:code> and <d:code>objdump -d -M=Intel test.o</d:code> is
      given below:
    </d:para>
    <d:programlisting role="ALexer"><![CDATA[test.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <f>:
   0:	48 83 ff ff          	cmp    $0xffffffffffffffff,%rdi
   4:	53                   	push   %rbx
   5:	48 89 fb             	mov    %rdi,%rbx
   8:	74 24                	je     2e <f+0x2e>
   a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
  10:	48 89 da             	mov    %rbx,%rdx
  13:	31 c0                	xor    %eax,%eax
  15:	be 00 00 00 00       	mov    $0x0,%esi
  1a:	bf 01 00 00 00       	mov    $0x1,%edi
  1f:	48 83 c3 01          	add    $0x1,%rbx
  23:	e8 00 00 00 00       	callq  28 <f+0x28>
  28:	48 83 fb ff          	cmp    $0xffffffffffffffff,%rbx
  2c:	75 e2                	jne    10 <f+0x10>
  2e:	5b                   	pop    %rbx
  2f:	48 c7 c2 ff ff ff ff 	mov    $0xffffffffffffffff,%rdx
  36:	be 00 00 00 00       	mov    $0x0,%esi
  3b:	bf 01 00 00 00       	mov    $0x1,%edi
  40:	31 c0                	xor    %eax,%eax
  42:	e9 00 00 00 00       	jmpq   47 <f+0x47>

Disassembly of section .text.startup:

0000000000000000 <main>:
   0:	48 83 ec 08          	sub    $0x8,%rsp
   4:	31 ff                	xor    %edi,%edi
   6:	e8 00 00 00 00       	callq  b <main+0xb>
   b:	31 c0                	xor    %eax,%eax
   d:	48 83 c4 08          	add    $0x8,%rsp
  11:	c3                   	retq]]></d:programlisting>
    <d:para>
      The key is the bottom of functions at locations <d:code>4c</d:code> and
      <d:code>42</d:code> respectively. As you can see in the first version
      <d:code>callq</d:code> instruction is called to call the function which
      is our recursive call but it is simply not their in optimized
      version. The question is how compiler can deduce. If you look at
      carefully call of function <d:code>f(0)</d:code> has no dependency on the
      values computed by <d:code>f(1)</d:code>, which has no further dependency
      on <d:code>f(2)</d:code> and so on. Thus the compiler can optimize in
      such a way that no new stack frames need to be created for further
      calls. But even before we tail recursion in more detail, let us try to
      capture what how recursive code is executed in terms of stack. I am
      giving an indicative diagram for that below:
    </d:para>
    <d:figure>
      <d:title>Sample Stack Diagram for Function Calls</d:title>
      <d:mediaobject>
        <d:imageobject>
          <d:imagedata fileref="../images/stack-exec.png" align="center" />
        </d:imageobject>
      </d:mediaobject>
    </d:figure>
    <d:para>
      As you can see when <d:code>main</d:code> calls <d:code>f(0)</d:code> a
      stack frame is created and again for <d:code>f(1)</d:code> and again for
      <d:code>f(2)</d:code> and it will continue untill all of stack is
      exhausted or <d:code>i</d:code> becomes equal to
      <d:code>ULONG_MAX</d:code>. Let us say we had infinite stack memory
      available to us then when <d:code>i</d:code> reaches the base case of
      <d:code>ULONG_MAX</d:code> then <d:code>f(ULONG_MAX)</d:code> will return
      and successively <d:code>f(ULONG_MAX -1 )</d:code> and others will follow
      in reverse order. This is known as stack unwinding.
    </d:para>
    <d:para>
      However, since we do not have infinite space available to us we need to
      use tail recursion. The fundamental principal behind tail recursion is
      that we should write in code in such a way that later calls of our
      function are not a dependency for earlier calls i.e. caller does not have
      a dependency on callee. If we can ensure that then compiler will be able
      to optimize that for us. This example was a trivial example. More
      involving recursive examples will have more complicated versions of tail
      recursive functions. Note that functional languages deploy tail recursion
      heavily to optimize their code execution. Tail recursion not only makes
      deep recursion possible but causes less consumption of memory. For
      example, you can increase your stack size to 1GB if you have enough RAM
      available by using the command <d:code>ulimit -s 1048576</d:code>. Then
      run the unoptimized version of binary and examine the memory usage which
      will go on increasing till the stack space is violated. There is no
      computer in this world which can run the unoptimized version of the
      program. The benefit is not only of memory. Even execution of a tail
      recursive version will be faster because it takes time to set up stack
      frames however small that is. It will matter for large stack sizes and
      deep recursion. Even the instruction <d:code>call</d:code> to call a
      function is expensive, relatively.
    </d:para>
    <d:para>
      Now I will present several recursive algorithms, evaluate their
      complexity, give implementations for both naive version and tail
      recursive version.
    </d:para>
  </d:sect1>
  <d:sect1>
    <d:title>Recursive Algorithms</d:title>
    <d:sect2>
      <d:title>Factorial Computation</d:title>
      <d:para>
        I straightaway present recursive implementation of factorial
        computation. First a naive version.
      </d:para>
      <d:programlisting role="CLexer"><![CDATA[//Description: Recursive factorial.

#include <stdio.h>

long long fact(unsigned int input);

int main()
{
  unsigned int input=0;

  printf("Enter a number whose factorial has to be computed:\n");
  scanf("%u", &input);

  printf("Factorial of %u is %lld.\n", input, fact(input));

  return 0;
}

long long fact(unsigned int input)
{
  if(input==0)
    return 1;
  else
    return fact(input-1)*input;
}]]></d:programlisting>
      <d:para>
        The problem with this implementation can be seen from the fact that
        compiler cannot optimize it for tail recursion. This can be seen from
        the assembly given below:
        <d:programlisting role="ALexer"><![CDATA[test.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <fact>:
   0:	53                   	push   rbx
   1:	89 fb                	mov    ebx,edi
   3:	b8 01 00 00 00       	mov    eax,0x1
   8:	85 db                	test   ebx,ebx
   a:	75 04                	jne    10 <fact+0x10>
   c:	5b                   	pop    rbx
   d:	c3                   	ret    
   e:	66 90                	xchg   ax,ax
  10:	8d 7b ff             	lea    edi,[rbx-0x1]
  13:	e8 00 00 00 00       	call   18 <fact+0x18>
  18:	48 0f af c3          	imul   rax,rbx
  1c:	5b                   	pop    rbx
  1d:	c3                   	ret]]></d:programlisting>
        Thus we will have to modify our code in the way we have discussed so
        that compiler can do necessary optimization. The improved version is
        given below:
      </d:para>
      <d:programlisting role="CLexer"><![CDATA[#include <stdio.h>

void factorial(unsigned int *index, unsigned int *input, unsigned long long *fact);

int main()
{
  unsigned int input = 0;
  unsigned int index = 1;
  unsigned long long fact = 1;

  printf("Enter a number whose factorial has to be computed:\n");
  scanf("%u", &input);

  factorial(&index, &input, &fact);

  printf("Factorial of %u is %llu.\n", input, fact);

  return 0;
}

void factorial(unsigned int *index, unsigned int *input, unsigned long long *fact)
{
  if(*index == *input) {
    return ;
  }
  else {
    *index += 1;
    *fact *= *index;
  }
  factorial(index, input, fact);
}]]></d:programlisting>
      and the equivalent assembly of our function is:
      <d:programlisting role="ALexer"><![CDATA[test.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <factorial>:
   0:	8b 07                	mov    (%rdi),%eax
   2:	3b 06                	cmp    (%rsi),%eax
   4:	74 1d                	je     23 <factorial+0x23>
   6:	48 8b 0a             	mov    (%rdx),%rcx
   9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  10:	83 c0 01             	add    $0x1,%eax
  13:	41 89 c0             	mov    %eax,%r8d
  16:	89 07                	mov    %eax,(%rdi)
  18:	49 0f af c8          	imul   %r8,%rcx
  1c:	39 06                	cmp    %eax,(%rsi)
  1e:	75 f0                	jne    10 <factorial+0x10>
  20:	48 89 0a             	mov    %rcx,(%rdx)
  23:	f3 c3                	repz retq]]></d:programlisting>
      <d:para>
        As you can see that <d:code>factrial</d:code> has been optimized for
        tail recursion. It may appear from above code that I have bypassed base
        case but it is not so. That is hidden in the way variables are
        initialized. <d:code>fact</d:code> is initialized with 1 which
        guaranteed that even for <d:code>input</d:code> having a value 0 our
        result is 1 and same for <d:code>input</d:code> having a value 1. Thus
        base cases are implicit in code.
      </d:para>
    </d:sect2>
    <d:sect2>
      <d:title>Fibinacci Series</d:title>
      <d:para>
        First I present the most naive version using multiple recursion which
        then I will convert quickly to single recursion and then present a tail
        recursive version.
      </d:para>
      <d:sect3>
        <d:title>Naive Version</d:title>
        <d:programlisting role="CLexer"><![CDATA[#include <stdio.h>

long long fibonacci(int input);

int main()
{
  int input=0;

  printf("Which Fibonacci number you want?\n");
  scanf("%d", &input);

  printf("%lld\n", fibonacci(input));

  return 0;
}

long long fibonacci(int input)
{
  long long fib1=1, fib2=1;

  if(input==1)
  {
    return fib1;
  }
  else if(input==2)
  {
    return fib2;
  }
  else
  {
    long long fib = fibonacci(input-1)+fibonacci(input-2);
    return fib;
  }
}]]></d:programlisting>
        <d:para>
          What is wrong? Well, it is terribly wrong. Consider following
          diagrams for function calls for different Fibonacci numbers(number
          inside circles indicate the position of that number in sequence and
          corresponding fib call):
        </d:para>
        <d:figure>
          <d:title>Function calls for 5th Fibonacci number</d:title>
          <d:mediaobject>
            <d:imageobject>
              <d:imagedata fileref="../images/fib5.png" align="center" />
            </d:imageobject>
          </d:mediaobject>
        </d:figure>
        <d:figure>
          <d:title>Function calls for 7th Fibonacci number</d:title>
          <d:mediaobject>
            <d:imageobject>
              <d:imagedata fileref="../images/fib7.png" align="center" />
            </d:imageobject>
          </d:mediaobject>
        </d:figure>
        <d:para>
          
        </d:para>
      </d:sect3>
    </d:sect2>
  </d:sect1>
  <d:bibliography>
    <d:title>Bibliography</d:title>
    <d:biblioentry>
      <d:abbrev>NK</d:abbrev>
      <d:authorgroup>
        <d:author>
          <d:personname>
            <d:firstname>
              Niklaus
            </d:firstname>
            <d:surname>
              Wirth
            </d:surname>
          </d:personname>
        </d:author>
      </d:authorgroup>
      <d:copyright>
        <d:year>1976</d:year>
        <d:holder>Prentice Hall</d:holder>
      </d:copyright>
      <d:citetitle>Algorithms + Data Structures = Programs</d:citetitle>
      <d:biblioid class="isbn">978-0-13-022418-7</d:biblioid>
    </d:biblioentry>
    <d:biblioentry>
      <d:abbrev>MFRBFMFSK</d:abbrev>
      <d:authorgroup>
        <d:author>
          <d:personname>
            <d:firstname>
              Matthais
            </d:firstname>
            <d:surname>
              Felleisen
            </d:surname>
          </d:personname>
        </d:author>
        <d:author>
          <d:personname>
            <d:firstname>
              Robert
            </d:firstname>
            <d:surname>
              Findler
            </d:surname>
          </d:personname>
        </d:author>
        <d:author>
          <d:personname>
            <d:firstname>
              Matthias
            </d:firstname>
            <d:surname>
              Flatt
            </d:surname>
          </d:personname>
        </d:author>
        <d:author>
          <d:personname>
            <d:firstname>
              Shriram
            </d:firstname>
            <d:surname>
              Krishnamurthy
            </d:surname>
          </d:personname>
        </d:author>      
      </d:authorgroup>
      <d:copyright>
        <d:year>2001</d:year>
        <d:holder>MIT Press</d:holder>
      </d:copyright>
      <d:citetitle>How to Design Programs: An Introduction to Computing and Programming</d:citetitle>
      <d:biblioid class="isbn">978-0-26-206218-3</d:biblioid>
    </d:biblioentry>
    <d:biblioentry>
      <d:abbrev>MF</d:abbrev>
      <d:authorgroup>
        <d:author>
          <d:personname>
            <d:firstname>
              Matthais
            </d:firstname>
            <d:surname>
              Felleisen
            </d:surname>
          </d:personname>
        </d:author>
      </d:authorgroup>
      <d:copyright>
        <d:year>2002</d:year>
        <d:holder>Springer, UK</d:holder>
      </d:copyright>
      <d:citetitle>Developing Interactive Web Programs. In <d:quote>Advanced
      Functional Programming: 4th International School</d:quote></d:citetitle>
      <d:biblioid class="isbn">978-3-540-44833-4-4</d:biblioid>
    </d:biblioentry>
  </d:bibliography>
</d:chapter>
